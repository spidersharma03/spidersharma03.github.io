
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - loaders - OBJ loader</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                font-family: Monospace;
                background-color: #000;
                color: #fff;
                margin: 0px;
                overflow: hidden;
            }
            #info {
                color: #fff;
                position: absolute;
                top: 10px;
                width: 100%;
                text-align: center;
                z-index: 100;
                display:block;
            }
            #info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
        </style>
    </head>

    <body>

        <script src="../../js/lib/three.js/three.js"></script>
        <script src="../../js/lib/three.js/ammo.js"></script>

        <script src="../../js/lib/three.js/js/controls/OrbitControls.js"></script>

        <script src="../../js/lib/three.js/js/Detector.js"></script>
        <script src="../../js/lib/three.js/js/libs/stats.min.js"></script>
        <script src="../../js/simulate/SpringMassSystems1D.js"></script>

        <script>

            var simulation = new SpringMassSystems1D();

            var container, stats;
            var pickConstraint = null;
            var camera, scene, renderer, controls;

            var fov = 70,
                    isUserInteracting = false,
                    onMouseDownMouseX = 0, onMouseDownMouseY = 0,
                    lon = 0, onMouseDownLon = 0,
                    lat = 0, onMouseDownLat = 0,
                    phi = 0, theta = 0;

            var mouseX = 0, mouseY = 0;

            var windowHalfX = window.innerWidth / 2;
            var windowHalfY = window.innerHeight / 2;

            var cubeMaterial;
            var groundMaterial;
            var sphereMaterial;

            var numSpheres = 2;
            var spheres = [];
            var physicsBodies = [];
            var boxMesh;
            
            var geometry;
            var sphereRadius = 1.0;
            var cradleWidth = 3.0;
            var cradleHeight = 3.0;
            var cradleLength = 5.0;
            var groundWidth = 1.5 * cradleLength;
            var groundDepth = 1.5 * cradleLength;
            var groundHeight = 0.1;

            var anchorPositions = [];
            var indices_array = [];
            var impulse = new Ammo.btVector3(-3, 0, 0);
            var impulsePoint = new Ammo.btVector3(0, 0, 0);

            var cameraPosition = new THREE.Vector3();

            var arcRadius = 7;
            var trackSize = 2.0;
            var dt = 0.016;
            var pauseSimulation = false;
            var com_visible = false;
            var comMesh;
           
            var angleLeft = 20 * Math.PI/180; // will remain fixed
            var angleRight = 20 * Math.PI/180; // can change
            var platformLength = 10;
            var platformMesh;
            var leftMesh, rightMesh;
            var leftRootMesh, rightRootMesh;
            var sphereMesh;
            var sphereRadius = 0.4;
            var g = -9.8;
            var contactNormalPlatform = new THREE.Vector2(0,1);
            var contactNormalLeftIncline = new THREE.Vector2(Math.sin(angleLeft), Math.cos(angleLeft));
            var contactNormalRightIncline = new THREE.Vector2(-Math.sin(angleRight), Math.cos(angleRight));
            var pointLeft = new THREE.Vector2(-platformLength/2, 0);
            var pointRight = new THREE.Vector2(platformLength/2, 0);
            var tempVector = new THREE.Vector2();
            
            init();
            animate();
            
            function reset() {
                pauseSimulation = false;
                syncSimulation();
                pauseSimulation = true;
            }
            
            function start_pause() {
                pauseSimulation = !pauseSimulation;
            }
            
            function timeScale(value) {
                dt = Number(value);
            }
            
            function toggleCOM() {
                com_visible = !com_visible;
                if(com_visible) {
                    scene.add(comMesh);
                }
                else {
                    scene.remove(comMesh);
                }
            }
            
            function makeBaseGeometry() {
                var geometry1 = new THREE.BoxGeometry(platformLength, 0.015, platformLength);
                platformMesh = new THREE.Mesh(geometry1, groundMaterial);
                scene.add(platformMesh);
                
                var geometry2 = new THREE.BoxGeometry(2*platformLength, 0.015, platformLength);
                leftRootMesh = new THREE.Object3D();
                leftMesh = new THREE.Mesh(geometry2, groundMaterial);
                leftRootMesh.position.x = -platformLength/2;
                leftRootMesh.add(leftMesh);
                leftMesh.rotation.z = -angleLeft;
                scene.add(leftRootMesh);
                leftMesh.castShadow = true;
                leftMesh.receiveShadow = true;
                
                var geometry3 = new THREE.BoxGeometry(2*platformLength, 0.015, platformLength);
                rightRootMesh = new THREE.Object3D();
                rightMesh = new THREE.Mesh(geometry3, groundMaterial);
                rightMesh.position.x = platformLength/2;
                rightMesh.rotation.z = angleRight;
                rightRootMesh.add(rightMesh);
                scene.add(rightRootMesh);
                rightMesh.castShadow = true;
                rightMesh.receiveShadow = true;
                
                var sphgeometry = new THREE.SphereGeometry(0.2,20,20);
                comMesh = new THREE.Object3D();
                var mesh1 = new THREE.Mesh(sphgeometry, cubeMaterial);
                comMesh.position.y = 0.5;
                comMesh.add(mesh1);
                
                var material = new THREE.LineBasicMaterial({color: 0x222222});
                var geometry = new THREE.Geometry();
                geometry.vertices.push(
                        new THREE.Vector3( 0, -10, 0 ),
                        new THREE.Vector3( 0, 10, 0 )
                                );
                var line = new THREE.Line( geometry, material );
                comMesh.add(line);
                //scene.add(comMesh);
            }

            function syncSimulation()
            {
                if(pauseSimulation)
                    return;
                sphereMesh.velocity.y += g*dt;
                var beta = 0.80;
                
                if( sphereMesh.position.x <= -platformLength/2) { // Sphere on the left incline
                   tempVector.copy(pointLeft);
                   tempVector.x = sphereMesh.position.x - tempVector.x;
                   tempVector.y = sphereMesh.position.y - tempVector.y;
                   var depth = contactNormalLeftIncline.dot(tempVector) - sphereRadius; 
                   if( depth < 0 ) {
                        var lambda = -contactNormalLeftIncline.dot(sphereMesh.velocity) + -beta*depth;  
                        sphereMesh.velocity.x += (contactNormalLeftIncline.x * lambda);
                        sphereMesh.velocity.y += (contactNormalLeftIncline.y * lambda);
                        //sphereMesh.position.x += contactNormalLeftIncline.x * -depth;
                        //sphereMesh.position.y += contactNormalLeftIncline.y * -depth;
                   }
                } 
                else if( sphereMesh.position.x > platformLength/2) { // Sphere on the right incline
                   tempVector.copy(pointRight);
                   tempVector.x = sphereMesh.position.x - tempVector.x;
                   tempVector.y = sphereMesh.position.y - tempVector.y;
                   var depth = contactNormalRightIncline.dot(tempVector) - sphereRadius;  
                   if( depth < 0 ) {
                        var lambda = -contactNormalRightIncline.dot(sphereMesh.velocity) + -beta*depth;  
                        sphereMesh.velocity.x += (contactNormalRightIncline.x * lambda);
                        sphereMesh.velocity.y += (contactNormalRightIncline.y * lambda);
                        //sphereMesh.position.x += contactNormalRightIncline.x * -depth;
                        //sphereMesh.position.y += contactNormalRightIncline.y * -depth;
                    }
                }
                else { // middle platform
                   tempVector.x = sphereMesh.position.x;
                   tempVector.y = sphereMesh.position.y;
                   var depth = contactNormalPlatform.dot(tempVector) - sphereRadius; 
                   if( depth < 0 ) {
                        var lambda = -contactNormalPlatform.dot(sphereMesh.velocity) + -beta*depth;  
                        sphereMesh.velocity.x += (contactNormalPlatform.x * lambda);
                        sphereMesh.velocity.y += (contactNormalPlatform.y * lambda);
                        //sphereMesh.position.x += contactNormalPlatform.x * -depth;
                        //sphereMesh.position.y += contactNormalPlatform.y * -depth;
                    }
                }
                sphereMesh.position.x += sphereMesh.velocity.x * dt;
                sphereMesh.position.y += sphereMesh.velocity.y * dt;
                var speed = sphereMesh.velocity.length();
                var omega = speed/sphereRadius;
                //sphereMesh.rotation.z += omega * dt;
                //console.log(simulation.v_com());
            }

            function init() {

                container = document.createElement('div');
                document.body.appendChild(container);

                camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100);
                camera.position.z = 22;
                camera.position.y = 4;
                controls = new THREE.OrbitControls(camera);
                controls.addEventListener('change', render);
                // scene

                scene = new THREE.Scene();

                var ambient = new THREE.AmbientLight(0x101030);
                scene.add(ambient);

                var light = new THREE.DirectionalLight(0xffeedd);
                light.position.set(50, 200, -100);
                //var light1 = new THREE.SpotLight( 0xffffff );
                //light1.position.set( 85, 85, 85 );
                //light1.target.position.set(0, 0, 0 );
                light.castShadow = true;
                light.shadowMapWidth = 1024;
                light.shadowMapHeight = 1024;

                var d = 20;

                light.shadowCameraLeft = -d;
                light.shadowCameraRight = d;
                light.shadowCameraTop = d;
                light.shadowCameraBottom = -d;

                light.shadowCameraFar = 1000;
                light.shadowDarkness = 0.5;
                scene.add(light);

                var light1 = new THREE.DirectionalLight(0xffeedd);
                light1.castShadow = false;
                light1.position.set(50, 200, 300);
                //scene.add( light1 );
                var hemiLight = new THREE.HemisphereLight(0xaabbff, 0x111111, 4.0);
                scene.add(hemiLight);

                // texture

                var manager = new THREE.LoadingManager();
                manager.onProgress = function (item, loaded, total) {

                    console.log(item, loaded, total);

                };

                var path = "../../img/pisa/";
                var format = '.png';
                var urls = [
                    path + 'px' + format, path + 'nx' + format,
                    path + 'py' + format, path + 'ny' + format,
                    path + 'pz' + format, path + 'nz' + format
                ];

                var reflectionCube = THREE.ImageUtils.loadTextureCube(urls);
                reflectionCube.format = THREE.RGBFormat;
                var texture = THREE.ImageUtils.loadTexture("../../img/dark-metal-texture.jpg");
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(1, 1);
                var sphereTexture = THREE.ImageUtils.loadTexture("../../img/billboard.jpeg");

                cubeMaterial = new THREE.MeshLambertMaterial({color: 0xffffff, envMap: reflectionCube, ambient: 0xaaaaaa, combine: THREE.MixOperation});
                groundMaterial = new THREE.MeshPhongMaterial({envMap: reflectionCube, map: texture, color: 0xffffff, specular: 0xffffff, combine: THREE.MixOperation, bumpScale: 0.010, bumpMap: texture, ambient: 0x555555, reflectivity: 0.5, metal: true, shininess: 1000});
                sphereMaterial = new THREE.MeshPhongMaterial({envMap: reflectionCube, map: sphereTexture, color: 0xff0000, specular: 0xffffff, combine: THREE.MixOperation, ambient: 0x555555, reflectivity: 0.8, shininess: 10});
                //sphereMaterial.emissive = new THREE.Color("rgb(0,255,0)");
                renderer = new THREE.WebGLRenderer({antialias: true});
                renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(renderer.domElement);

                document.addEventListener('mousemove', onDocumentMouseMove, false);
                document.addEventListener('mousedown', onDocumentMouseDown, false);
                document.addEventListener('mouseup', onDocumentMouseUp, false);
                document.addEventListener('mousewheel', onDocumentMouseWheel, false);

                window.addEventListener('resize', onWindowResize, false);


                renderer.shadowMapEnabled = true;
                renderer.shadowMapSoft = true;

                makeBaseGeometry();                
               
                
                var geometry = new THREE.SphereGeometry(sphereRadius, 30, 30);
                sphereMesh = new THREE.Mesh(geometry, sphereMaterial);
                scene.add(sphereMesh);
                sphereMesh.velocity = new THREE.Vector2();
                sphereMesh.position.x = -platformLength;
                sphereMesh.position.y = platformLength/2;
                sphereMesh.castShadow = true;
                sphereMesh.receiveShadow = true;
                pauseSimulation = false;
                syncSimulation();
                //pauseSimulation = true;
            }

            function onDocumentMouseMove(event)
            {
                var pos = camera.position;

                if (pos.y < 2)
                {
                    //pos.y = 2;
                }
            }

            function onDocumentMouseWheel(event)
            {
                var pos = camera.position;
                var d = pos.length();
                cameraPosition.x = pos.x;
                cameraPosition.y = pos.y;
                cameraPosition.z = pos.z;
                var min = 5;
                var max = 40;
                if (d < min)
                {
                    cameraPosition.normalize();
                    pos.x = cameraPosition.x * min;
                    pos.y = cameraPosition.y * min;
                    pos.z = cameraPosition.z * min;
                }
                if (d > max)
                {
                    cameraPosition.normalize();
                    pos.x = cameraPosition.x * max;
                    pos.y = cameraPosition.y * max;
                    pos.z = cameraPosition.z * max;
                }

            }

            function onDocumentMouseDown(e)
            {
            }

            function onDocumentMouseUp(e)
            {
            }

            function onWindowResize() {

                windowHalfX = window.innerWidth / 2;
                windowHalfY = window.innerHeight / 2;

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);

            }

//			function onDocumentMouseMove( event ) {
//
//				mouseX = ( event.clientX - windowHalfX ) / 2;
//				mouseY = ( event.clientY - windowHalfY ) / 2;
//
//			}

            //

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                syncSimulation();
                render();
            }

            function render() {
                renderer.setClearColor(0xffffff, 1);
                //lat = Math.max( - 85, Math.min( 85, lat ) );
//				phi = THREE.Math.degToRad( 90 - lat );
//				theta = THREE.Math.degToRad( lon );

//                                camera.position.z = 100 * Math.sin( phi ) * Math.cos( theta );
//				camera.position.y = 100 * Math.cos( phi );
//				camera.position.x = 100 * Math.sin( phi ) * Math.sin( theta );

                //camera.lookAt( scene.position );
                renderer.render(scene, camera);
// 1479
            }

        </script>

    </body>
</html>
