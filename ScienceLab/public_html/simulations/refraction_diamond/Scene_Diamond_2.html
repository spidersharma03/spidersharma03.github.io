
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - loaders - OBJ loader</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                font-family: Monospace;
                background-color: #000;
                color: #fff;
                margin: 0px;
                overflow: hidden;
            }
            #info {
                color: #fff;
                position: absolute;
                top: 10px;
                width: 100%;
                text-align: center;
                z-index: 100;
                display:block;
            }
            #info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
        </style>
    </head>

    <body>

        <script src="../../js/lib/three.js/three.js"></script>
        <script src="../../js/lib/three.js/js/controls/OrbitControls.js"></script>
        <script src="../../js/lib/three.js/js/Detector.js"></script>
        <script src="../../js/lib/three.js/js/libs/stats.min.js"></script>
        <script src="../../js/lib/three.js/js/loaders/OBJLoader.js"></script>
        <script src="../../js/lib/three.js/js/loaders/ColladaLoader.js"></script>
        <script src="../../js/lib/three.js/js/postprocessing/EffectComposer.js"></script>
        <script src="../../js/lib/three.js/js/postprocessing/RenderPass.js"></script>
        <script src="../../js/lib/three.js/js/postprocessing/MaskPass.js"></script>
        <script src="../../js/lib/three.js/js/postprocessing/ShaderPass.js"></script>
        <script src="../../js/lib/three.js/js/postprocessing/BloomPass.js"></script>
        <script src="../../js/lib/three.js/js/postprocessing/FilmPass.js"></script>
        <script src="../../js/lib/three.js/js/shaders/BokehShader.js"></script>
        <script src="../../js/lib/three.js/js/postprocessing/BokehPass.js"></script>
        <script src="../../js/lib/three.js/js/shaders/FXAAShader.js"></script>
        <script src="../../js/lib/three.js/js/shaders/CopyShader.js"></script>
        <script src="../../js/lib/three.js/js/shaders/ConvolutionShader.js"></script>
        <script src="../../js/lib/three.js/js/shaders/FilmShader.js"></script>
        
        <script src="HDREnvTextureLoader.js"></script>
        <script src="DiamondLoader.js"></script>
        <script src="Diamond.js"></script>

        <script>

var container, stats;
var camera, backgroundCamera, sceneBackground, scene, renderer, controls, sceneScreen;
var count = 0;
var composer, dpr, effectFXAA, bloomPass, renderScene, renderSceneBg;

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

var cameraPosition = new THREE.Vector3();
var boundingSphere;
var coneRadius;
var bRotate = false;
var bObjectLoaded = false;
var IsIBLDataRead = false;
var rootNode = new THREE.Object3D();

var diamondArray = [];

function initDiamondRing() {
    
}

function initDiamonds() {
    var radius = 2;
    var n = 50;
    var theta = 0;
    var dTheta = 2*Math.PI/(n+1);
    for(var i=0; i<n; i++) {
        var diamondCopy = diamond.shallowCopy();
        rootNode.add(diamondCopy.mesh);
        diamondCopy.setRotation(0, 0, -theta);
        diamondCopy.setScale(0.13,0.13,0.13);
        theta -= dTheta;
        var x = radius * Math.sin(theta);
        var y = radius * Math.cos(theta);
        diamondCopy.setPosition(x, y, 0);
        diamondCopy.applyTransform();
        diamondArray.push(diamondCopy);
    }
    scene.add(rootNode);
}

function initMainDiamond() {
    var radius = 2;
    var diamond1 = diamondRect.shallowCopy();
    diamond1.setPosition(0,radius,0);
    diamond1.setScale(0.5, 0.5, 0.5);
    diamond1.applyTransform();
    diamondArray.push(diamond1);
    rootNode.add(diamond1.mesh);
    
    var theta = Math.PI/9;
    var diamond2 = diamondRect.shallowCopy();
    diamond2.setRotation(0,0,-theta);
    diamond2.setPosition(radius*Math.sin(theta),radius*Math.cos(theta),0);
    diamond2.setScale(0.35, 0.35, 0.35);
    diamond2.applyTransform();
    diamondArray.push(diamond2);
    rootNode.add(diamond2.mesh);
    
    theta = -theta;
    var diamond3 = diamondRect.shallowCopy();
    diamond3.setRotation(0,0,-theta);
    diamond3.setPosition(radius*Math.sin(theta),radius*Math.cos(theta),0);
    diamond3.setScale(0.35, 0.35, 0.35);
    diamond3.applyTransform();
    diamondArray.push(diamond3);
    rootNode.add(diamond3.mesh);
}
var onReadyCallBack1 = function() {
    sceneScreen.add(diamond.normalBakeHelperMesh);
    initDiamonds();
    bObjectLoaded = true;
};

var onReadyCallBack2 = function() {
    sceneScreen.add(diamondRect.normalBakeHelperMesh);
    initMainDiamond();
    bObjectLoaded = true;
};

var onIBLInfoReadyCallBack = function(roughnessArray, uniformTexCoordSetArray) {
    DiamondShader.material.uniforms['TextureCoordSetArray'].value = uniformTexCoordSetArray;
    DiamondShader.material.uniforms['RoughnessArray'].value = roughnessArray;
    IsIBLDataRead = true;
};

var envTextureLoader = new HDREnvTextureLoader();
envTextureLoader.loadIBLInfo("../../img/IBL_Info.txt", onIBLInfoReadyCallBack);
var envTexture = envTextureLoader.load('../../img/mips.png');
DiamondShader.material.uniforms["IBLTexture"].value = envTexture;
var diamond = new Diamond('../../img/Diamond_Round_Cut.obj', onReadyCallBack1);
var diamondRect = new Diamond('../../img/wafercut.obj', onReadyCallBack2);

init();
animate();

function toggleRotation() {
    bRotate = !bRotate;
};

function changeAbsorbption(index, value) {
    if(index === 0)
        DiamondShader.material.uniforms["Absorbption"].value.x = Number(value);
    if(index === 1)    
        DiamondShader.material.uniforms["Absorbption"].value.y = Number(value);
    if(index === 2)    
        DiamondShader.material.uniforms["Absorbption"].value.z = Number(value);
}

function changeTexture() {
    currentTextureIndex++;
    if(currentTextureIndex >= textureNames.length)
        currentTextureIndex = 0;
    loadEnvTexture(textureNames[currentTextureIndex]);
}

function changeDiamond() {
    currentDiamondIndex++;
    if(currentDiamondIndex >= diamondNames.length)
        currentDiamondIndex = 0;
    
    loadDiamondObject(diamondNames[currentDiamondIndex]);
}

function changeHDRYWhite(value) {
    DiamondShader.material.uniforms["YWhite"].value = Number(value);
}

function changeHDRLogAvgLum(value) {
    DiamondShader.material.uniforms["LogAvgLum"].value = Number(value);
}

function changeHDRKey(value) {
    DiamondShader.material.uniforms["Key"].value = Number(value);
}

function changeHDRSaturation(value) {
    DiamondShader.material.uniforms["Saturation"].value = Number(value);
}

function changeRefractiveIndex(value) {
    DiamondShader.material.uniforms["n2"].value = Number(value);
}

function changeConeRadiusScale(value) {
    var scaledConeRadius = coneRadius * Number(value);
    var tanAngle = scaledConeRadius / DiamondShader.material.uniforms["coneHeight"].value;
    DiamondShader.material.uniforms["tanAngleSqCone"].value = tanAngle * tanAngle;
}

function changeBoundingSphereSquashFactor(value) {
    DiamondShader.material.uniforms["squashFactor"].value = boundingSphere.radius * Number(value);
}

function changeBoundingSphereRadiusScale(value) {
    DiamondShader.material.uniforms["boundingSphereRadius"].value = boundingSphere.radius * Number(value);
}

function changeBloomStrength(value) {
    bloomPass.materialCopy.uniforms["opacity"].value = Number(value);
}

function changeBloomSigma(value) {
    bloomPass.convolutionUniforms[ "cKernel" ].value = THREE.ConvolutionShader.buildKernel(Number(value));
}

function changeNormalOffset(value) {
    DiamondShader.material.uniforms["normalOffset"].value = Number(value);
}

function toggleIntersectionGeometry() {
    DiamondShader.material.uniforms["bIntersectSphere"].value = !DiamondShader.material.uniforms["bIntersectSphere"].value;
}

function toggleDebugMode() {
    DiamondShader.material.uniforms["bDebugBounces"].value = !DiamondShader.material.uniforms["bDebugBounces"].value;
}

function changeBounceCount(value) {
    DiamondShader.material.uniforms["maxBounces"].value = Number(value);
}
function changeRIndexDelta(value) {
    DiamondShader.material.uniforms["rIndexDelta"].value = Number(value);
}

function init() {
    container = document.createElement('div');
    document.body.appendChild(container);

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.3, 100);
    camera.position.z = 3;
    camera.position.y = 0;
    controls = new THREE.OrbitControls(camera);
    controls.addEventListener('change', render);
    // scene
    scene = new THREE.Scene();
    sceneScreen = new THREE.Scene();
    sceneScreen.add(diamond.cubeCamera);
    
    // Background Scene
    var bgTexture = THREE.ImageUtils.loadTexture( '../../img/bg.jpg' );
    var backgroundMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(window.innerWidth / window.innerHeight*2, 2, 0),
            new THREE.MeshBasicMaterial({
                map: bgTexture
            }));
    backgroundMesh.material.side = THREE.DoubleSide;        
    backgroundMesh.material.depthTest = false;
    backgroundMesh.material.depthWrite = false;

    sceneBackground = new THREE.Scene();
    backgroundCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.3, 100);
    backgroundCamera.position.z = 2;
    sceneBackground .add(backgroundCamera);
    sceneBackground .add(backgroundMesh );
    
    dpr = 1;
    if (window.devicePixelRatio !== undefined) {
        dpr = window.devicePixelRatio;
    }

    renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true, antialias: false});
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    renderSceneBg = new THREE.RenderPass(sceneBackground, backgroundCamera);
    renderScene = new THREE.RenderPass(scene, camera);
    renderScene.clear = false;
    effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
    effectFXAA.uniforms['resolution'].value.set(1 / (window.innerWidth * dpr), 1 / (window.innerHeight * dpr));
    effectFXAA.renderToScreen = true;
    //var effectFilm = new THREE.FilmPass(0.35, 0.95, 1024, false);
    //effectFilm.renderToScreen = true;
    bloomPass = new THREE.BloomPass(1.0, 25, 4.0, 512);
    var bokehPass = new THREE.BokehPass( scene, camera, {
            focus: 		1.0,
            aperture:	0.025,
            maxblur:	1.0,

            width: window.innerWidth,
            height: window.innerHeight
    } );

    bokehPass.renderToScreen = true;
                                
    renderer.autoClear = false;
    composer = new THREE.EffectComposer(renderer);
    composer.setSize(window.innerWidth * dpr, window.innerHeight * dpr);
    //        renderer.render( sceneBackground, backgroundCamera );
    composer.addPass(renderSceneBg);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);
    composer.addPass(effectFXAA);
    //composer.addPass(bokehPass);
//                composer.addPass(renderScene);
//                composer.addPass(effectFilm);

    document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('mousedown', onDocumentMouseDown, false);
    document.addEventListener('mouseup', onDocumentMouseUp, false);
    document.addEventListener('mousewheel', onDocumentMouseWheel, false);
    window.addEventListener('dblclick', keydown, false);
    window.addEventListener('resize', onWindowResize, false);

    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '0px';
    container.appendChild(stats.domElement);
    
//    var loaderCollada = new THREE.ColladaLoader();
//    loaderCollada.options.convertUpAxis = true;
//    loaderCollada.load( '../../img/test.dae', function ( collada ) {
//        var dae = collada.scene;
//        scene.add(dae);
//        dae.traverse( function ( child ) {
//            if(child instanceof THREE.Mesh) {
//                child.material = diamondMaterial;
//            }
//        } );
//    } );

}

function keydown(e) {
    var newwindow = window.open("");
    var dataUrl = renderer.domElement.toDataURL("image/png");
    var img = new Image();
    img.src = dataUrl;
    img.width /= 2;
    img.height /= 2;
    newwindow.document.body.appendChild(img);
}
function onDocumentMouseMove(event)
{
    var pos = camera.position;

    if (pos.y < 2)
    {
        //pos.y = 2;
    }
}

function onDocumentMouseWheel(event)
{
    var pos = camera.position;
    var d = pos.length();
    cameraPosition.x = pos.x;
    cameraPosition.y = pos.y;
    cameraPosition.z = pos.z;
    var min = 1;
    var max = 100;
    if (d < min)
    {
        cameraPosition.normalize();
        pos.x = cameraPosition.x * min;
        pos.y = cameraPosition.y * min;
        pos.z = cameraPosition.z * min;
    }
    if (d > max)
    {
        cameraPosition.normalize();
        pos.x = cameraPosition.x * max;
        pos.y = cameraPosition.y * max;
        pos.z = cameraPosition.z * max;
    }

}

function onDocumentMouseDown(e)
{
}

function onDocumentMouseUp(e)
{
}

function onWindowResize() {
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    //composer.setSize(window.innerWidth, window.innerHeight);
//    uniforms.resolution.value.x = window.innerWidth;
//    uniforms.resolution.value.y = window.innerHeight;
//
//    renderer.setSize( window.innerWidth, window.innerHeight );
//
//    camera.aspect = window.innerWidth / window.innerHeight;
//    camera.updateProjectionMatrix();
    composer.setSize(window.innerWidth, window.innerHeight);
}
    
function animate() {
    requestAnimationFrame(animate);
    if (IsIBLDataRead && bObjectLoaded) {
        controls.update();
        stats.update();
        render();
        if(bRotate) {
            rootNode.rotation.y += 0.00516;
            for(var i=0; i<diamondArray.length; i++){
                diamondArray[i].applyTransform();
            }
//            DiamondShader.material.uniforms["ModelMatrix"].value.copy(diamondNode.matrix);
//            var m1 = DiamondShader.material.uniforms["ModelMatrix"].value;
//            var m2 = DiamondShader.material.uniforms["InverseModelMatrix"].value;
//            m2.getInverse(m1);
        }
    }
}

function render() {
    renderer.autoClear = false;
    renderer.clear();
    if (count < 3)
    {
        count++;
        //renderer.render(sceneScreen, camera);
        diamond.prepareNormalsCubeMap(renderer, sceneScreen);
        diamondRect.prepareNormalsCubeMap(renderer, sceneScreen);
        for(var i=0; i<diamondArray.length; i++) {
            diamondArray[i].material.uniforms["tCubeMap"].value = diamond.cubeCamera.renderTarget;
            diamondArray[i].material.uniforms["IBLTexture"].value = envTexture;
        }
    }
    if (count >= 3) 
    {
        //renderer.setClearColor(0x000000, 1);
//        renderer.render( sceneBackground, backgroundCamera );
//        renderer.render( scene, camera );
        composer.render(0.1);
    }
}

        </script>

    </body>
</html>
