
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - loaders - OBJ loader</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                font-family: Monospace;
                background-color: #000;
                color: #fff;
                margin: 0px;
                overflow: hidden;
            }
            #info {
                color: #fff;
                position: absolute;
                top: 10px;
                width: 100%;
                text-align: center;
                z-index: 100;
                display:block;
            }
            #info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
        </style>
    </head>

    <body>

        <script src="../../js/lib/three.js/three.js"></script>
        <script src="../../js/lib/three.js/js/controls/OrbitControls.js"></script>
        <script src="../../js/lib/three.js/js/Detector.js"></script>
        <script src="../../js/lib/three.js/js/libs/stats.min.js"></script>
        <script src="../../js/lib/three.js/js/loaders/OBJLoader.js"></script>
        <script src="../../js/lib/three.js/js/loaders/ColladaLoader.js"></script>
        <script src="../../js/lib/three.js/js/postprocessing/EffectComposer.js"></script>
        <script src="../../js/lib/three.js/js/postprocessing/RenderPass.js"></script>
        <script src="../../js/lib/three.js/js/postprocessing/MaskPass.js"></script>
        <script src="../../js/lib/three.js/js/postprocessing/ShaderPass.js"></script>
        <script src="../../js/lib/three.js/js/postprocessing/BloomPass.js"></script>
        <script src="../../js/lib/three.js/js/postprocessing/FilmPass.js"></script>
        <script src="../../js/lib/three.js/js/shaders/BokehShader.js"></script>
        <script src="../../js/lib/three.js/js/postprocessing/BokehPass.js"></script>
        <script src="../../js/lib/three.js/js/shaders/FXAAShader.js"></script>
        <script src="../../js/lib/three.js/js/shaders/CopyShader.js"></script>
        <script src="../../js/lib/three.js/js/shaders/ConvolutionShader.js"></script>
        <script src="../../js/lib/three.js/js/shaders/FilmShader.js"></script>
        <script src="../../js/IBL/MaterialLibrary.js"></script>

        <script src="HDREnvTextureLoader.js"></script>
        <script src="DiamondLoader.js"></script>
        <script src="Sparkle.js"></script>
        <script src="Diamond.js"></script>

        <script>

var container, stats;
var camera, backgroundCamera, sceneBackground, scene, renderer, controls;
var count = 0;
var composer, dpr, effectFXAA, bloomPass, renderScene, renderSceneBg, sceneSparkles, renderSceneSparkles;

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

var cameraPosition = new THREE.Vector3();
var bRotate = true;
var bObjectLoaded = false;
var IsIBLDataRead = false;
var rootNode = new THREE.Object3D();

var sparkleTexture = THREE.ImageUtils.loadTexture( '../../img/sparkle5.png' );
var sparkleTexture1 = THREE.ImageUtils.loadTexture( '../../img/sparkle3.png' );
var noiseTexture = THREE.ImageUtils.loadTexture( '../../img/noiseTexture.jpg' );
var sparkle1 = new Sparkle(sparkleTexture, noiseTexture);

var diamondArray = [];
var diamondPrototypeArray = [];

                
function initDiamonds() {
    var radius = 2;
    var n = 50;
    var theta = 0;
    var dTheta = 2*Math.PI/(n+1);
    for(var i=0; i<n; i++) {
        var diamondCopy = diamondPrototype1.shallowCopy();
        rootNode.add(diamondCopy.mesh);
        diamondCopy.setRotation(0, 0, -theta);
        diamondCopy.setScale(0.13,0.13,0.13);
        theta -= dTheta;
        var x = radius * Math.sin(theta);
        var y = radius * Math.cos(theta);
        diamondCopy.setPosition(x, y, 0);
        diamondCopy.applyTransform();
        diamondArray.push(diamondCopy);
    }
}

function initMainDiamond() {
    var radius = 2;
    var diamond1 = diamondPrototype2.shallowCopy();
    diamond1.setPosition(0,radius,0);
    diamond1.setScale(0.5, 0.5, 0.5);
    diamond1.applyTransform();
    diamondArray.push(diamond1);
    rootNode.add(diamond1.mesh);
    
    var theta = Math.PI/9;
    var diamond2 = diamondPrototype2.shallowCopy();
    diamond2.setRotation(0,0,-theta);
    diamond2.setPosition(radius*Math.sin(theta),radius*Math.cos(theta),0);
    diamond2.setScale(0.35, 0.35, 0.35);
    diamond2.applyTransform();
    diamondArray.push(diamond2);
    rootNode.add(diamond2.mesh);
    var absorbption = diamond2.material.uniforms["Absorbption"].value;
    absorbption.x = 0.85;
    absorbption.z = 0.85;
    
    theta = -theta;
    var diamond3 = diamondPrototype2.shallowCopy();
    diamond3.setRotation(0,0,-theta);
    diamond3.setPosition(radius*Math.sin(theta),radius*Math.cos(theta),0);
    diamond3.setScale(0.35, 0.35, 0.35);
    diamond3.applyTransform();
    diamondArray.push(diamond3);
    rootNode.add(diamond3.mesh);
    var absorbption = diamond3.material.uniforms["Absorbption"].value;
    absorbption.y = 0.35;
    absorbption.z = 0.85;
}

var onReadyCallBack1 = function() {
    initDiamonds();
    bObjectLoaded = true;
};

var onReadyCallBack2 = function() {
    initMainDiamond();
    bObjectLoaded = true;
};

var onReadyCallBack3 = function() {
    var diamondOval = diamondPrototype3.shallowCopy();
    diamondOval.setScale(0.5, 0.5, 0.5);
    diamondOval.applyTransform();
    diamondArray.push(diamondOval);
    rootNode.add(diamondOval.mesh);
    bObjectLoaded = true;
};

var onReadyCallBack4 = function() {
    var ringRadius = 1.8;
    var diamond = diamondPrototype4.shallowCopy();
    diamond.setScale(0.5,0.75,0.5);
    diamond.setPosition(0,ringRadius,0);
    diamondArray.push(diamond);
    rootNode.add(diamond.mesh);
    
    sparkle1.material.uniforms["screenTexture"].value = composer.renderTarget2;
    sparkle1.setScale(0.5);
    sparkle1.setPositionOffset(0.5, 0.4,0);
    diamond.addSparkle(sparkle1);
    
    var copySparkle1 = sparkle1.shallowCopy();
    copySparkle1.setPositionOffset(-0.5, 0.4,0);
    diamond.addSparkle(copySparkle1);
    
    sceneSparkles.add(sparkle1.mesh);
    sceneSparkles.add(copySparkle1.mesh);
    
    var copySparkle2 = sparkle1.shallowCopy();
    copySparkle2.setPositionOffset(-0.5, 0.4,0.5);
    diamond.addSparkle(copySparkle2);
    sceneSparkles.add(copySparkle2.mesh);
    diamond.applyTransform();
    //diamond.setRotation(0.5, 0, 0.15);
    
    var dTheta = Math.PI/10;
    var theta = -3*dTheta;
    var radius = 2.7;
    var cy = -1;
    for(var j=0; j<= 6; j++) {
        if(theta !== 0) {
            var copyDiamond = diamond.shallowCopy();
//            var absorbption = diamond.material.uniforms["Absorbption"].value;
//            absorbption.x = 1;
//            absorbption.y = 2;
//            absorbption.z = 0.3;
            copyDiamond.setPosition(radius*Math.sin(theta), cy + radius*Math.cos(theta),0,0);
            copyDiamond.setRotation(0,0,-theta);
            copyDiamond.setScale(0.5,0.75,0.5);
            diamondArray.push(copyDiamond);
            rootNode.add(copyDiamond.mesh);
            for(var i=0; i<copyDiamond.sparkles.length; i++) {
                copyDiamond.sparkles[i].setScale(2);
                sceneSparkles.add(copyDiamond.sparkles[i].mesh);
            }
            copyDiamond.applyTransform();
        }
        theta += dTheta;
    }
    dTheta = Math.PI/20;
    theta = 3*dTheta;
    radius *= 1.03;
    for(var j=0; j<= 30; j++) {
        if(theta !== 0) {
            var copyDiamond = diamond.shallowCopy();
            copyDiamond.setPosition(radius*Math.sin(theta), cy + radius*Math.cos(theta),0,0);
            copyDiamond.setRotation(0,0,-theta);
            copyDiamond.setScale(0.25,0.5,0.25);
            diamondArray.push(copyDiamond);
            rootNode.add(copyDiamond.mesh);
            for(var i=0; i<copyDiamond.sparkles.length; i++) {
                copyDiamond.sparkles[i].setScale(1);
                sceneSparkles.add(copyDiamond.sparkles[i].mesh);
            }
            copyDiamond.applyTransform();
        }
        theta += dTheta;
    }
    bObjectLoaded = true;
};

var onIBLInfoReadyCallBack = function(roughnessArray, uniformTexCoordSetArray) {
    DiamondShader.material.uniforms['TextureCoordSetArray'].value = uniformTexCoordSetArray;
    DiamondShader.material.uniforms['RoughnessArray'].value = roughnessArray;
    IsIBLDataRead = true;
};

var envTextureLoader = new HDREnvTextureLoader();
envTextureLoader.loadIBLInfo("../../img/IBL_Info.txt", onIBLInfoReadyCallBack);
var envTexture = envTextureLoader.load('../../img/mips.png');
envTexture.generateMipmaps = false;
envTexture.magFilter = THREE.LinearFilter;
envTexture.minFilter = THREE.LinearFilter;
//var diamondPrototype1 = new Diamond('../../img/Diamond_Round_Cut.obj', envTexture, onReadyCallBack1);
//var diamondPrototype2 = new Diamond('../../img/wafercut.obj', envTexture, onReadyCallBack2);
//var diamondPrototype3 = new Diamond('../../img/oval.obj', envTexture, onReadyCallBack3);
var diamondPrototype4 = new Diamond('../../img/Diamond_Round_Cut.obj', envTexture, onReadyCallBack4);
//diamondPrototypeArray.push(diamondPrototype1);
//diamondPrototypeArray.push(diamondPrototype2);
//diamondPrototypeArray.push(diamondPrototype3);
diamondPrototypeArray.push(diamondPrototype4);
var library = new MaterialLibrary();
var specularTexture = THREE.ImageUtils.loadTexture("../../img/gold.jpg");
var roughnessTexture = THREE.ImageUtils.loadTexture("../../img/roughness_copper.jpg");
roughnessTexture.wrapS = THREE.RepeatWrapping;
roughnessTexture.wrapT = THREE.RepeatWrapping;
specularTexture.wrapS = THREE.RepeatWrapping;
specularTexture.wrapT = THREE.RepeatWrapping;
                
library.shaderSource.uniforms['IBLTexture'].value = envTexture;
library.shaderSource.uniforms['SpecularMap'].value = specularTexture;                                
library.shaderSource.uniforms['RoughnessMap'].value = roughnessTexture;                                
library.shaderSource.uniforms['SpecularColor'].value = new THREE.Vector4(1.0,0.6,0.15,1.0);                
library.shaderSource.uniforms['DiffuseColor'].value = new THREE.Vector4(0.01,0.01,0.01,1.0);                
library.shaderSource.uniforms['uMetal'].value = 0.0;
library.shaderSource.uniforms['metalRoughness'].value = 0.2;

var metalMaterial = new THREE.ShaderMaterial(
        {uniforms: library.shaderSource.uniforms, 
        vertexShader:library.shaderSource.vertexShader,
        fragmentShader:library.shaderSource.fragmentShader});
metalMaterial.map = true;
metalMaterial.side = THREE.DoubleSide;

initScene();
//loadMetalObject();
animate();


function changeMetalRoughness(value) {
    library.shaderSource.uniforms['metalRoughness'].value = Number(value);
}
    
function changeMetalColor(index, value) {
    if(index === 0)
        library.shaderSource.uniforms['SpecularColor'].value.x = Number(value);                
    if(index === 1)
        library.shaderSource.uniforms['SpecularColor'].value.y = Number(value);                
    if(index === 2)
        library.shaderSource.uniforms['SpecularColor'].value.z = Number(value);                
}
function loadMetalObject() {
    var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {

					console.log( item, loaded, total );

				};

                var loader = new THREE.OBJLoader( manager );
                loader.load( '../../img/ring1.obj', function ( object ) {
                        objNode = object;
                        object.traverse( function ( child ) {

                                if ( child instanceof THREE.Mesh ) {

                                        child.material = metalMaterial;
                                        //child.geometry.center();
                                        child.geometry.normalize();
                                        child.position.y = -1;
                                        child.scale.x = 0.75;
                                        child.scale.y = 0.75;
                                        child.scale.z = 0.75;
                                        
                                        child.geometry.computeVertexNormals();
                                }
                        } );
                        
                        object.position.y = 3;
                        object.scale.x = 4;
                        object.scale.y = 4;
                        object.scale.z = 4;
                        rootNode.add( object );
                } );
}

function toggleRotation() {
    bRotate = !bRotate;
};


function changeBloomStrength(value) {
    bloomPass.materialCopy.uniforms["opacity"].value = Number(value);
}


function initScene() {
    container = document.createElement('div');
    document.body.appendChild(container);

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.3, 100);
    camera.position.z = 8;
    camera.position.y = 0;
    controls = new THREE.OrbitControls(camera);
    controls.addEventListener('change', render);
    // scene
    scene = new THREE.Scene();
    scene.add(rootNode);
    // Background Scene
    var bgTexture = THREE.ImageUtils.loadTexture( '../../img/bg1.jpg' );
    var backgroundMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(window.innerWidth / window.innerHeight*3, 3, 0),
            new THREE.MeshBasicMaterial({
                map: bgTexture
            }));
    backgroundMesh.material.side = THREE.DoubleSide;        
    backgroundMesh.material.depthTest = false;
    backgroundMesh.material.depthWrite = false;

    sceneBackground = new THREE.Scene();
    backgroundCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.3, 100);
    backgroundCamera.position.z = 3;
    sceneBackground .add(backgroundCamera);
    sceneBackground .add(backgroundMesh );
    
    dpr = 1;
    if (window.devicePixelRatio !== undefined) {
        dpr = window.devicePixelRatio;
    }

    renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true, antialias: false});
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);
    
    renderSceneBg = new THREE.RenderPass(sceneBackground, backgroundCamera);
    renderScene = new THREE.RenderPass(scene, camera);
    renderScene.clear = false;
    effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
    effectFXAA.uniforms['resolution'].value.set(1 / (window.innerWidth * dpr), 1 / (window.innerHeight * dpr));
    effectFXAA.renderToScreen = true;

    bloomPass = new THREE.BloomPass(1.0, 25, 0.25, 512);
    bloomPass.clear = true;
    
    composer = new THREE.EffectComposer(renderer);
    composer.setSize(window.innerWidth * dpr, window.innerHeight * dpr);
    composer.addPass(renderSceneBg);
    composer.addPass(renderScene);
    //composer.addPass(bloomPass);
    composer.addPass(effectFXAA);
    
    sceneSparkles = new THREE.Scene();
    
    document.addEventListener('mousemove', onDocumentMouseMove, false);
    document.addEventListener('mousedown', onDocumentMouseDown, false);
    document.addEventListener('mouseup', onDocumentMouseUp, false);
    document.addEventListener('mousewheel', onDocumentMouseWheel, false);
    window.addEventListener('resize', onWindowResize, false);

    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '0px';
    container.appendChild(stats.domElement);
}

function onDocumentMouseMove(event)
{
}

function onDocumentMouseWheel(event)
{
    var pos = camera.position;
    var d = pos.length();
    cameraPosition.x = pos.x;
    cameraPosition.y = pos.y;
    cameraPosition.z = pos.z;
    var min = 1;
    var max = 100;
    if (d < min)
    {
        cameraPosition.normalize();
        pos.x = cameraPosition.x * min;
        pos.y = cameraPosition.y * min;
        pos.z = cameraPosition.z * min;
    }
    if (d > max)
    {
        cameraPosition.normalize();
        pos.x = cameraPosition.x * max;
        pos.y = cameraPosition.y * max;
        pos.z = cameraPosition.z * max;
    }

}

function onDocumentMouseDown(e)
{
}

function onDocumentMouseUp(e)
{
}

function onWindowResize() {
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    //composer.setSize(window.innerWidth, window.innerHeight);
//    uniforms.resolution.value.x = window.innerWidth;
//    uniforms.resolution.value.y = window.innerHeight;
//
//    renderer.setSize( window.innerWidth, window.innerHeight );
//
//    camera.aspect = window.innerWidth / window.innerHeight;
//    camera.updateProjectionMatrix();
    effectFXAA.uniforms['resolution'].value.set(1/window.innerWidth, 1/window.innerHeight);
    //composer.setSize(window.innerWidth, window.innerHeight);
}
    
function animate() {
    requestAnimationFrame(animate);
    if (IsIBLDataRead && bObjectLoaded) {
        controls.update();
        stats.update();
        for(var i=0; i<diamondArray.length; i++){
                diamondArray[i].alignSparklesWithCamera(camera);
        }
        render();
        if(bRotate) {
            rootNode.rotation.y += 0.00516;
            for(var i=0; i<diamondArray.length; i++){
                diamondArray[i].applyTransform();
            }
        }
    }
}

function render() {
    renderer.autoClear = false;
    renderer.clear();
    if (count < 3)
    {
        count++;
        for(var i=0; i<diamondPrototypeArray.length; i++) {
            diamondPrototypeArray[i].prepareNormalsCubeMap(renderer);
        }
    }
    if (count >= 3) 
    {
        composer.render();
        renderer.render(sceneSparkles, camera);
    }
}

        </script>

    </body>
</html>
